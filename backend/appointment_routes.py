"""
Appointments API Routes
Handles appointment scheduling and management
"""

from flask import Blueprint, jsonify, request
from functools import wraps
from datetime import datetime, timedelta
try:
    import pytz
    MANILA_TZ = pytz.timezone('Asia/Manila')
except ImportError:
    # Fallback to zoneinfo for Python 3.9+
    try:
        from zoneinfo import ZoneInfo
        MANILA_TZ = ZoneInfo('Asia/Manila')
    except ImportError:
        # If neither available, use UTC offset (UTC+8)
        from datetime import timezone
        MANILA_TZ = timezone(timedelta(hours=8))

from auth.firebase_auth import firebase_auth_required
from db.supabase_client import SupabaseClient

appointments_bp = Blueprint("appointments", __name__, url_prefix="/api/appointments")
# Initialize Supabase client with error handling
try:
    supabase = SupabaseClient()
    print("‚úÖ Supabase client initialized for appointments")
except Exception as e:
    print(f"‚ùå Error initializing Supabase client for appointments: {e}")
    supabase = None

def get_manila_now():
    """Get current datetime in Asia/Manila timezone"""
    if hasattr(MANILA_TZ, 'localize'):
        # pytz timezone
        return datetime.now(MANILA_TZ)
    else:
        # zoneinfo or timezone offset
        return datetime.now(MANILA_TZ)


def auth_required(f):
    """Decorator that accepts both Firebase and Supabase tokens"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        auth_header = request.headers.get("Authorization")
        
        if not auth_header:
            return jsonify({"error": "No authorization header provided"}), 401
        
        try:
            token = auth_header.split(" ")[1]  # Remove 'Bearer ' prefix
        except IndexError:
            return jsonify({"error": "Invalid authorization header format"}), 401
        
        # Try Firebase token first
        from auth.firebase_auth import firebase_auth_service
        firebase_result = firebase_auth_service.verify_token(token)

        if firebase_result["success"]:
            request.firebase_user = firebase_result
            return f(*args, **kwargs)

        # If Firebase fails, try accepting a Supabase-style JWT (no signature verification in dev)
        try:
            import jwt
            # Decode the JWT without verification (development only)
            decoded = jwt.decode(token, options={"verify_signature": False})

            # Accept Supabase JWTs with sub/email
            if 'sub' in decoded and 'email' in decoded:
                request.firebase_user = {
                    "success": True,
                    "uid": decoded.get('sub'),
                    "email": decoded.get('email')
                }
                print(f"‚úÖ Supabase JWT accepted for user: {decoded.get('email')}")
                return f(*args, **kwargs)
        except Exception as e:
            print(f"‚ö†Ô∏è  Token decoding failed (supabase-style): {e}")

        # Finally, accept app-issued JWTs (medichain_token) generated by auth_utils
        try:
            from auth.auth_utils import auth_utils
            app_payload = auth_utils.decode_token(token)
            if app_payload and app_payload.get('email'):
                # Normalize to expected context keys
                request.firebase_user = {
                    "success": True,
                    "uid": app_payload.get('user_id'),
                    "email": app_payload.get('email'),
                    "role": app_payload.get('role')
                }
                print(f"‚úÖ App JWT accepted for user: {app_payload.get('email')}")
                return f(*args, **kwargs)
        except Exception as e:
            print(f"‚ö†Ô∏è  App JWT decoding failed: {e}")
        
        return jsonify({"error": "Invalid or expired token"}), 401
    
    return decorated_function


# Test route to debug
@appointments_bp.route("/test", methods=["GET"])
def test_route():
    """Test route to verify API is working"""
    return jsonify({"success": True, "message": "Appointments API is working"}), 200


@appointments_bp.route("/doctors/approved", methods=["GET"])
@auth_required
def get_approved_doctors():
    """Get list of approved doctors for appointment booking with availability"""
    try:
        print("üìã Fetching approved doctors...")
        # Fetch approved doctors from database using service_client to bypass RLS
        response = (
            supabase.service_client.table("user_profiles")
            .select("id, firebase_uid, first_name, last_name, email, verification_status")
            .eq("role", "doctor")
            .eq("verification_status", "approved")
            .execute()
        )
        print(f"‚úÖ Found {len(response.data) if response.data else 0} approved doctors")

        if not response.data:
            return jsonify({"success": True, "doctors": [], "message": "No approved doctors available"}), 200

        # Fetch doctor profiles with specializations and availability
        doctors = []
        for user in response.data:
            try:
                doctor_profile_response = (
                    supabase.service_client.table("doctor_profiles")
                    .select("specialization, availability")
                    .eq("firebase_uid", user["firebase_uid"])
                    .execute()
                )
                
                specialization = "General Practitioner"
                availability = []
                has_availability = False
                is_accepting_appointments = True  # Default to True if column doesn't exist
                
                if doctor_profile_response.data and len(doctor_profile_response.data) > 0:
                    specialization = doctor_profile_response.data[0].get("specialization", "General Practitioner")
                    availability_raw = doctor_profile_response.data[0].get("availability", {})
                    
                    # Try to get is_accepting_appointments, default to True if not present
                    try:
                        is_accepting_appointments = doctor_profile_response.data[0].get("is_accepting_appointments", True)
                    except (KeyError, AttributeError):
                        is_accepting_appointments = True
                    
                    # Debug logging
                    print(f"üîç Doctor {user.get('email')}: availability_raw type = {type(availability_raw)}")
                    print(f"üîç Doctor {user.get('email')}: availability_raw = {availability_raw}")
                    print(f"üîç Doctor {user.get('email')}: is_accepting_appointments = {is_accepting_appointments}")
                    
                    # Check availability based on format
                    # New format: { time_ranges: [{ start_time, end_time, interval }, ...] }
                    # Old format: [{ date: "...", time_slots: [...] }, ...]
                    if isinstance(availability_raw, dict) and availability_raw:
                        # New format with time_ranges
                        if "time_ranges" in availability_raw and isinstance(availability_raw["time_ranges"], list):
                            print(f"üîç Doctor {user.get('email')}: Found time_ranges with {len(availability_raw['time_ranges'])} ranges")
                            if len(availability_raw["time_ranges"]) > 0:
                                # If doctor has time_ranges defined AND is accepting appointments, they have availability
                                has_availability = is_accepting_appointments
                                print(f"‚úÖ Doctor {user.get('email')}: has_availability = {has_availability} (has time_ranges, accepting={is_accepting_appointments})")
                            else:
                                print(f"‚ùå Doctor {user.get('email')}: has_availability = False (empty time_ranges)")
                            availability = availability_raw  # Store the raw availability object
                        # Legacy single range format: { start_time, end_time, interval }
                        elif "start_time" in availability_raw and "end_time" in availability_raw:
                            print(f"‚úÖ Doctor {user.get('email')}: Found legacy format, converting to time_ranges")
                            # Convert to time_ranges format for consistency
                            availability = {
                                "time_ranges": [{
                                    "start_time": availability_raw.get("start_time", "07:00"),
                                    "end_time": availability_raw.get("end_time", "17:00"),
                                    "interval": availability_raw.get("interval", 30)
                                }]
                            }
                            has_availability = is_accepting_appointments
                        else:
                            print(f"‚ùå Doctor {user.get('email')}: Dict format but no time_ranges or start_time/end_time found")
                    elif isinstance(availability_raw, list) and len(availability_raw) > 0:
                        print(f"üîç Doctor {user.get('email')}: Found list format (old format)")
                        # Old format: array of date slots
                        availability = availability_raw
                        # Check if any slots are in the future
                        today = datetime.now().date()
                        for slot in availability_raw:
                            if isinstance(slot, dict) and "date" in slot:
                                slot_date = datetime.strptime(slot["date"], "%Y-%m-%d").date()
                                if slot_date >= today and slot.get("time_slots"):
                                    has_availability = is_accepting_appointments
                                    break
                    else:
                        print(f"‚ùå Doctor {user.get('email')}: availability_raw is empty or invalid: {type(availability_raw)}")
                    
                    print(f"üîç Doctor {user.get('email')}: Final has_availability = {has_availability}")
            except Exception as profile_error:
                print(f"‚ö†Ô∏è  Error fetching profile for {user.get('email')}: {profile_error}")
                import traceback
                traceback.print_exc()
                # Continue with default values if profile fetch fails
                specialization = "General Practitioner"
                availability = []
                has_availability = False
                is_accepting_appointments = True

            doctors.append(
                {
                    "id": user["id"],
                    "firebase_uid": user["firebase_uid"],
                    "name": f"{user.get('first_name', '')} {user.get('last_name', '')}".strip(),
                    "first_name": user.get("first_name", ""),
                    "last_name": user.get("last_name", ""),
                    "email": user.get("email", ""),
                    "specialization": specialization,
                    "verification_status": user.get("verification_status", "approved"),
                    "availability": availability,
                    "has_availability": has_availability,
                }
            )

        print(f"‚úÖ Returning {len(doctors)} doctors")
        return jsonify({"success": True, "doctors": doctors, "count": len(doctors)}), 200

    except Exception as e:
        print(f"Error fetching approved doctors: {str(e)}")
        return jsonify({"success": False, "error": "Failed to fetch doctors", "message": str(e)}), 500


@appointments_bp.route("", methods=["GET"])
@firebase_auth_required
def get_appointments():
    """Get user's appointments"""
    try:
        firebase_user = request.firebase_user
        uid = firebase_user["uid"]

        # Get user profile to determine role
        user_response = supabase.client.table("user_profiles").select("role").eq("firebase_uid", uid).execute()
        if not user_response.data:
            return jsonify({"success": False, "error": "User profile not found"}), 404

        user_role = user_response.data[0]["role"]

        if user_role == "patient":
            # Patients see their own appointments
            response = supabase.client.table("appointments").select("*").eq("patient_firebase_uid", uid).execute()
        elif user_role == "doctor":
            # Doctors see their appointments
            response = supabase.client.table("appointments").select("*").eq("doctor_firebase_uid", uid).execute()
            # Enrich with basic patient info for schedule views
            if response.data:
                try:
                    patient_uids = sorted({appt.get("patient_firebase_uid") for appt in response.data if appt.get("patient_firebase_uid")})
                    if patient_uids:
                        profiles_resp = (
                            supabase.service_client
                            .table("user_profiles")
                            .select("firebase_uid, first_name, last_name, email")
                            .in_("firebase_uid", patient_uids)
                            .execute()
                        )
                        uid_to_patient = {p["firebase_uid"]: {
                            "first_name": p.get("first_name", ""),
                            "last_name": p.get("last_name", ""),
                            "email": p.get("email", "")
                        } for p in (profiles_resp.data or [])}
                        for appt in response.data:
                            pfuid = appt.get("patient_firebase_uid")
                            if pfuid and pfuid in uid_to_patient:
                                appt["patient"] = uid_to_patient[pfuid]
                except Exception as _e:
                    # If enrichment fails, continue with base data
                    pass
        else:
            return jsonify({"success": False, "error": "Unauthorized role"}), 403

        # Enrich appointments with meeting_url parsed from notes (if present)
        enriched = []
        for appt in (response.data or []):
            try:
                notes = appt.get("notes") or ""
                meeting_url = None
                for line in str(notes).splitlines():
                    if "Meeting:" in line and "http" in line:
                        meeting_url = line.split("Meeting:", 1)[1].strip()
                        break
                if meeting_url:
                    appt["meeting_url"] = meeting_url
            except Exception:
                pass
            enriched.append(appt)

        return jsonify({"success": True, "appointments": enriched}), 200

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@appointments_bp.route("", methods=["POST"])
@firebase_auth_required
def create_appointment():
    """Create a new appointment and remove booked time from doctor availability"""
    try:
        firebase_user = request.firebase_user
        uid = firebase_user["uid"]
        data = request.get_json()

        # Validate required fields
        required_fields = ["doctor_firebase_uid", "appointment_date", "appointment_time"]
        for field in required_fields:
            if field not in data:
                return (
                    jsonify({"success": False, "error": f"Missing required field: {field}"}),
                    400,
                )

        # Get user role
        user_response = supabase.client.table("user_profiles").select("role, first_name, last_name").eq("firebase_uid", uid).execute()
        if not user_response.data:
            return jsonify({"success": False, "error": "User profile not found"}), 404

        user_role = user_response.data[0]["role"]

        if user_role != "patient":
            return jsonify({"success": False, "error": "Only patients can book appointments"}), 403

        # Check if the time slot is available in doctor's availability
        doctor_profile = (
            supabase.client.table("doctor_profiles")
            .select("availability")
            .eq("firebase_uid", data["doctor_firebase_uid"])
            .execute()
        )

        if not doctor_profile.data:
            return jsonify({"success": False, "error": "Doctor not found"}), 404

        availability = doctor_profile.data[0].get("availability", {})
        appointment_date = data["appointment_date"]
        appointment_time = data["appointment_time"]

        # Check availability based on format
        # New format: { time_ranges: [{ start_time, end_time, interval }, ...] }
        # or legacy single range: { start_time, end_time, interval }
        if isinstance(availability, dict):
            time_ranges = []
            # Check for new format with time_ranges array
            if "time_ranges" in availability and isinstance(availability["time_ranges"], list):
                time_ranges = availability["time_ranges"]
            # Legacy single range format
            elif "start_time" in availability:
                time_ranges = [{
                    "start_time": availability.get("start_time", "07:00"),
                    "end_time": availability.get("end_time", "17:00"),
                    "interval": availability.get("interval", 30)
                }]
            
            if time_ranges:
                # Parse appointment time
                try:
                    appt_hour, appt_min = map(int, appointment_time.split(":"))
                    appt_minutes = appt_hour * 60 + appt_min
                except ValueError:
                    return jsonify({"success": False, "error": "Invalid appointment time format"}), 400
                
                # Check if appointment time matches any range
                time_found = False
                for time_range in time_ranges:
                    start_hour, start_min = map(int, time_range["start_time"].split(":"))
                    end_hour, end_min = map(int, time_range["end_time"].split(":"))
                    start_minutes = start_hour * 60 + start_min
                    end_minutes = end_hour * 60 + end_min
                    interval = time_range.get("interval", 30)
                    
                    # Check if time is within this range
                    if appt_minutes >= start_minutes and appt_minutes < end_minutes:
                        # Check if time matches interval
                        relative_minutes = appt_minutes - start_minutes
                        if relative_minutes % interval == 0:
                            time_found = True
                            break
                
                if not time_found:
                    return jsonify({"success": False, "error": "Selected time is outside doctor's availability hours or doesn't match the interval"}), 400
                
                # Check if appointment time is in the past (using Manila timezone)
                try:
                    now_manila = get_manila_now()
                    slot_datetime_naive = datetime.strptime(f"{appointment_date} {appointment_time}", "%Y-%m-%d %H:%M")
                    
                    # Localize to Manila timezone
                    if hasattr(MANILA_TZ, 'localize'):
                        # pytz timezone
                        slot_datetime_manila = MANILA_TZ.localize(slot_datetime_naive)
                    else:
                        # zoneinfo or timezone offset
                        slot_datetime_manila = slot_datetime_naive.replace(tzinfo=MANILA_TZ)
                    
                    if slot_datetime_manila <= now_manila:
                        return jsonify({"success": False, "error": "Cannot book appointments in the past"}), 400
                except ValueError:
                    return jsonify({"success": False, "error": "Invalid date or time format"}), 400
        
        # Old format: array of date slots
        elif isinstance(availability, list):
            date_slot = next((slot for slot in availability if slot.get("date") == appointment_date), None)
            
            if not date_slot or appointment_time not in date_slot.get("time_slots", []):
                return jsonify({"success": False, "error": "Selected time slot is not available"}), 400
        
        # No availability set
        else:
            return jsonify({"success": False, "error": "Doctor has not set availability"}), 400

        # Check if appointment already exists for this time slot
        existing_appointment = (
            supabase.client.table("appointments")
            .select("id")
            .eq("doctor_firebase_uid", data["doctor_firebase_uid"])
            .eq("appointment_date", appointment_date)
            .eq("appointment_time", appointment_time)
            .eq("status", "scheduled")
            .execute()
        )

        if existing_appointment.data:
            return jsonify({"success": False, "error": "This time slot has already been booked"}), 400

        # Create Jitsi meeting details
        import uuid
        safe_date = appointment_date.replace("-", "")
        safe_time = appointment_time.replace(":", "")
        room_suffix = uuid.uuid4().hex[:8]
        room_name = f"medichain-{data['doctor_firebase_uid']}-{safe_date}-{safe_time}-{room_suffix}"
        meeting_url = f"https://meet.jit.si/{room_name}#config.prejoinPageEnabled=true"

        # Create the appointment (persist only known columns)
        appointment_data = {
            "patient_firebase_uid": uid,
            "doctor_firebase_uid": data["doctor_firebase_uid"],
            "appointment_date": appointment_date,
            "appointment_time": appointment_time,
            "appointment_type": data.get("appointment_type", "general-practitioner"),
            "notes": (data.get("notes", "") or "").strip() + (f"\nMeeting: {meeting_url}" if meeting_url else ""),
            "status": "scheduled"
        }

        response = supabase.client.table("appointments").insert(appointment_data).execute()

        if not response.data:
            return jsonify({"success": False, "error": "Failed to create appointment"}), 500

        # For old format only: Remove the booked time slot from doctor's availability
        # New format doesn't need this since availability is schedule-based
        if isinstance(availability, list):
            updated_availability = []
            for slot in availability:
                if slot["date"] == appointment_date:
                    # Remove the booked time
                    remaining_times = [t for t in slot["time_slots"] if t != appointment_time]
                    # Only keep the date if there are remaining time slots
                    if remaining_times:
                        updated_availability.append({
                            "date": slot["date"],
                            "time_slots": remaining_times
                        })
                else:
                    updated_availability.append(slot)

            # Update doctor's availability (old format only)
            supabase.client.table("doctor_profiles").update({
                "availability": updated_availability
            }).eq("firebase_uid", data["doctor_firebase_uid"]).execute()

        # Optionally: send notifications (stubbed route currently)
        try:
            from notifications.notification_routes import notifications_bp  # noqa: F401
            print(f"üîî Appointment created. Meeting URL: {meeting_url}")
        except Exception:
            pass

        return (
            jsonify(
                {
                    "success": True,
                    "appointment": response.data[0] if response.data else None,
                    "message": "Appointment booked successfully!",
                    "meeting_url": meeting_url,
                }
            ),
            201,
        )

    except Exception as e:
        print(f"Error creating appointment: {str(e)}")
        return jsonify({"success": False, "error": str(e)}), 500


@appointments_bp.route("/<appointment_id>", methods=["PUT"])
@firebase_auth_required
def update_appointment(appointment_id):
    """Update an appointment"""
    try:
        firebase_user = request.firebase_user
        uid = firebase_user["uid"]
        data = request.get_json()

        # Update appointment (RLS ensures users can only update their own appointments)
        response = (
            supabase.client.table("appointments")
            .update(data)
            .eq("id", appointment_id)
            .or_(f"patient_firebase_uid.eq.{uid},doctor_firebase_uid.eq.{uid}")
            .execute()
        )

        if response.data:
            return jsonify({"success": True, "appointment": response.data[0]}), 200
        else:
            return jsonify({"success": False, "error": "Appointment not found or unauthorized"}), 404

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


# Doctor Availability Routes
@appointments_bp.route("/availability", methods=["GET"])
@firebase_auth_required
def get_doctor_availability():
    """Get current doctor's availability schedule"""
    try:
        firebase_user = request.firebase_user
        uid = firebase_user["uid"]

        # Verify user is a doctor
        user_response = supabase.client.table("user_profiles").select("role").eq("firebase_uid", uid).execute()
        if not user_response.data or user_response.data[0]["role"] != "doctor":
            return jsonify({"success": False, "error": "Only doctors can access this endpoint"}), 403

        # Get doctor's availability and accepting status (handle gracefully if column doesn't exist)
        try:
            response = (
                supabase.client.table("doctor_profiles")
                .select("availability, is_accepting_appointments")
                .eq("firebase_uid", uid)
                .execute()
            )
        except Exception as select_error:
            # If column doesn't exist, try without it
            print(f"‚ö†Ô∏è  Warning: Error selecting is_accepting_appointments: {select_error}")
            print(f"‚ö†Ô∏è  Falling back to availability only (assuming is_accepting_appointments = True)")
            response = (
                supabase.client.table("doctor_profiles")
                .select("availability")
                .eq("firebase_uid", uid)
                .execute()
            )
        
        if not response.data:
            return jsonify({"success": False, "error": "Doctor profile not found"}), 404

        availability = response.data[0].get("availability", {})
        is_accepting_appointments = response.data[0].get("is_accepting_appointments", True)
        
        return jsonify({
            "success": True, 
            "availability": availability,
            "is_accepting_appointments": is_accepting_appointments
        }), 200

    except Exception as e:
        print(f"Error fetching availability: {str(e)}")
        return jsonify({"success": False, "error": str(e)}), 500


@appointments_bp.route("/availability", methods=["PUT"])
@firebase_auth_required
def update_doctor_availability():
    """Update doctor's availability schedule (new format: time range + interval)"""
    try:
        firebase_user = request.firebase_user
        uid = firebase_user["uid"]
        data = request.get_json()
        
        print(f"DEBUG: Received availability update request from user {uid}")
        print(f"DEBUG: Request data: {data}")
        print(f"DEBUG: Request Content-Type: {request.content_type}")
        
        if data is None:
            return jsonify({"success": False, "error": "Invalid request. JSON data is required."}), 400
        
        # Check if Supabase client is available
        if supabase is None or supabase.client is None:
            print("ERROR: Supabase client is not initialized")
            return jsonify({"success": False, "error": "Database connection failed. Please try again later."}), 500

        # Verify user is a doctor
        user_response = supabase.client.table("user_profiles").select("role").eq("firebase_uid", uid).execute()
        if not user_response.data or user_response.data[0]["role"] != "doctor":
            return jsonify({"success": False, "error": "Only doctors can update availability"}), 403

        # Validate availability data - support both old format (array) and new format (object)
        availability = data.get("availability", {})
        
        if not availability:
            return jsonify({"success": False, "error": "Availability data is required"}), 400
        
        print(f"DEBUG: Availability data: {availability}")
        print(f"DEBUG: Availability type: {type(availability)}")
        
        # New format: { time_ranges: [{ start_time, end_time, interval }, ...] }
        # or legacy single range: { start_time, end_time, interval }
        if isinstance(availability, dict):
            # Check for new format with time_ranges array
            if "time_ranges" in availability and isinstance(availability["time_ranges"], list):
                if len(availability["time_ranges"]) == 0:
                    return jsonify({"success": False, "error": "At least one time range is required"}), 400
                
                # Validate each time range
                for i, time_range in enumerate(availability["time_ranges"]):
                    if not isinstance(time_range, dict):
                        return jsonify({"success": False, "error": f"Time range {i+1} must be an object"}), 400
                    
                    if "start_time" not in time_range or "end_time" not in time_range or "interval" not in time_range:
                        return jsonify({"success": False, "error": f"Time range {i+1} must include start_time, end_time, and interval"}), 400
                    
                    # Validate time format
                    try:
                        datetime.strptime(time_range["start_time"], "%H:%M")
                        datetime.strptime(time_range["end_time"], "%H:%M")
                    except ValueError:
                        return jsonify({"success": False, "error": f"Time range {i+1}: Invalid time format. Use HH:MM"}), 400
                    
                    # Validate interval
                    interval = time_range.get("interval")
                    if interval is None:
                        return jsonify({"success": False, "error": f"Time range {i+1}: Interval is required"}), 400
                    
                    # Convert interval to int if it's a string
                    try:
                        interval = int(interval)
                    except (ValueError, TypeError):
                        return jsonify({"success": False, "error": f"Time range {i+1}: Interval must be a number"}), 400
                    
                    if interval not in [15, 25, 30]:
                        return jsonify({"success": False, "error": f"Time range {i+1}: Interval must be 15, 25, or 30 minutes"}), 400
                    
                    # Validate end time is after start time
                    start_hour, start_min = map(int, time_range["start_time"].split(":"))
                    end_hour, end_min = map(int, time_range["end_time"].split(":"))
                    start_minutes = start_hour * 60 + start_min
                    end_minutes = end_hour * 60 + end_min
                    
                    if end_minutes <= start_minutes:
                        return jsonify({"success": False, "error": f"Time range {i+1}: End time must be after start time"}), 400
                
                # Check for overlaps between ranges
                for i in range(len(availability["time_ranges"])):
                    for j in range(i + 1, len(availability["time_ranges"])):
                        range1 = availability["time_ranges"][i]
                        range2 = availability["time_ranges"][j]
                        
                        start1_hour, start1_min = map(int, range1["start_time"].split(":"))
                        end1_hour, end1_min = map(int, range1["end_time"].split(":"))
                        start2_hour, start2_min = map(int, range2["start_time"].split(":"))
                        end2_hour, end2_min = map(int, range2["end_time"].split(":"))
                        
                        start1_minutes = start1_hour * 60 + start1_min
                        end1_minutes = end1_hour * 60 + end1_min
                        start2_minutes = start2_hour * 60 + start2_min
                        end2_minutes = end2_hour * 60 + end2_min
                        
                        # Check if ranges overlap
                        if not (end1_minutes <= start2_minutes or start1_minutes >= end2_minutes):
                            return jsonify({"success": False, "error": f"Time ranges {i+1} and {j+1} overlap. Please adjust them."}), 400
            
            # Legacy single range format: { start_time, end_time, interval }
            elif "start_time" in availability and "end_time" in availability:
                # Validate time format
                try:
                    datetime.strptime(availability["start_time"], "%H:%M")
                    datetime.strptime(availability["end_time"], "%H:%M")
                except ValueError:
                    return jsonify({"success": False, "error": "Invalid time format. Use HH:MM"}), 400
                
                # Validate interval
                if availability.get("interval") not in [15, 25, 30]:
                    return jsonify({"success": False, "error": "Interval must be 15, 25, or 30 minutes"}), 400
                
                # Validate end time is after start time
                start_hour, start_min = map(int, availability["start_time"].split(":"))
                end_hour, end_min = map(int, availability["end_time"].split(":"))
                start_minutes = start_hour * 60 + start_min
                end_minutes = end_hour * 60 + end_min
                
                if end_minutes <= start_minutes:
                    return jsonify({"success": False, "error": "End time must be after start time"}), 400
            
            else:
                return jsonify({"success": False, "error": "Availability must include time_ranges array or start_time/end_time/interval"}), 400
        
        # Old format: array of date slots (keep for backward compatibility)
        elif isinstance(availability, list):
            if not all(isinstance(slot, dict) and "date" in slot and "time_slots" in slot for slot in availability):
                return jsonify({"success": False, "error": "Invalid availability format"}), 400

        # Get is_accepting_appointments from request (optional, defaults to True if not provided)
        is_accepting_appointments = data.get("is_accepting_appointments", True)
        
        # Update doctor's availability and accepting status
        try:
            # Try to update both fields, but handle gracefully if column doesn't exist
            update_data = {
                "availability": availability
            }
            
            # Only include is_accepting_appointments if the column exists
            # If it doesn't exist, the update will still succeed but won't set this field
            try:
                update_data["is_accepting_appointments"] = is_accepting_appointments
            except Exception:
                pass  # Column might not exist yet
            
            print(f"DEBUG: Updating availability for user {uid}")
            print(f"DEBUG: Update data: {update_data}")
            
            response = (
                supabase.client.table("doctor_profiles")
                .update(update_data)
                .eq("firebase_uid", uid)
                .execute()
            )

            if not response.data:
                print(f"ERROR: Supabase update returned no data for user {uid}")
                return jsonify({"success": False, "error": "Failed to update availability. Doctor profile may not exist."}), 400

            print(f"DEBUG: Successfully updated availability for user {uid}")
            return jsonify({
                "success": True, 
                "availability": availability,
                "is_accepting_appointments": is_accepting_appointments,
                "message": "Availability updated successfully"
            }), 200
        
        except Exception as db_error:
            print(f"ERROR: Database update failed: {str(db_error)}")
            # Check if error is about missing column
            if "is_accepting_appointments" in str(db_error).lower() or "column" in str(db_error).lower():
                print(f"‚ö†Ô∏è  Warning: is_accepting_appointments column may not exist. Updating availability only.")
                # Try updating without is_accepting_appointments
                try:
                    response = (
                        supabase.client.table("doctor_profiles")
                        .update({"availability": availability})
                        .eq("firebase_uid", uid)
                        .execute()
                    )
                    if response.data:
                        return jsonify({
                            "success": True, 
                            "availability": availability,
                            "message": "Availability updated successfully (Note: Please run database migration to enable toggle feature)"
                        }), 200
                except Exception as retry_error:
                    return jsonify({"success": False, "error": f"Database error: {str(retry_error)}"}), 500
            return jsonify({"success": False, "error": f"Database error: {str(db_error)}"}), 500

    except Exception as e:
        print(f"ERROR: Exception in update_doctor_availability: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500


@appointments_bp.route("/availability/<doctor_firebase_uid>", methods=["GET"])
@auth_required
def get_doctor_availability_by_uid(doctor_firebase_uid):
    """Get specific doctor's availability (for patients booking appointments)
    Returns availability in format that can be used to generate date-time slots"""
    try:
        print(f"üîç Getting availability for doctor: {doctor_firebase_uid}")
        
        # Get doctor's availability and accepting status (handle gracefully if column doesn't exist)
        try:
            response = (
                supabase.client.table("doctor_profiles")
                .select("availability, is_accepting_appointments")
                .eq("firebase_uid", doctor_firebase_uid)
                .execute()
            )
        except Exception as select_error:
            # If column doesn't exist, try without it
            print(f"‚ö†Ô∏è  Warning: Error selecting is_accepting_appointments: {select_error}")
            print(f"‚ö†Ô∏è  Falling back to availability only (assuming is_accepting_appointments = True)")
            response = (
                supabase.client.table("doctor_profiles")
                .select("availability")
                .eq("firebase_uid", doctor_firebase_uid)
                .execute()
            )

        if not response.data:
            print(f"‚ùå Doctor not found: {doctor_firebase_uid}")
            return jsonify({"success": False, "error": "Doctor not found"}), 404

        availability = response.data[0].get("availability", {})
        is_accepting_appointments = response.data[0].get("is_accepting_appointments", True)
        
        print(f"üîç Doctor availability data: {availability}")
        print(f"üîç Is accepting appointments: {is_accepting_appointments}")
        
        # If doctor is not accepting appointments, return empty availability
        if not is_accepting_appointments:
            print(f"‚ö†Ô∏è  Doctor {doctor_firebase_uid} is not accepting appointments")
            return jsonify({
                "success": True,
                "availability": {},
                "schedule": availability,
                "message": "Doctor is currently not accepting appointments"
            }), 200
        
        # New format with multiple ranges: { time_ranges: [{ start_time, end_time, interval }, ...] }
        # or legacy single range: { start_time, end_time, interval }
        if isinstance(availability, dict):
            time_ranges = []
            
            # Check for new format with time_ranges array
            if "time_ranges" in availability and isinstance(availability["time_ranges"], list):
                time_ranges = availability["time_ranges"]
            # Legacy single range format
            elif "start_time" in availability:
                time_ranges = [{
                    "start_time": availability.get("start_time", "07:00"),
                    "end_time": availability.get("end_time", "17:00"),
                    "interval": availability.get("interval", 30)
                }]
            
            if time_ranges:
                # Generate time slots for next 30 days based on Asia/Manila timezone
                time_slots_per_date = {}
                now_manila = get_manila_now()
                today_manila = now_manila.date()
                
                for day_offset in range(30):
                    date = today_manila + timedelta(days=day_offset)
                    date_str = date.isoformat()
                    
                    # Generate time slots for this date from all ranges
                    all_slots = []
                    
                    for time_range in time_ranges:
                        start_time = time_range.get("start_time", "07:00")
                        end_time = time_range.get("end_time", "17:00")
                        interval = time_range.get("interval", 30)
                        
                        # Parse times
                        start_hour, start_min = map(int, start_time.split(":"))
                        end_hour, end_min = map(int, end_time.split(":"))
                        start_minutes = start_hour * 60 + start_min
                        end_minutes = end_hour * 60 + end_min
                        
                        # Generate time slots for this range
                        current_minutes = start_minutes
                        
                        while current_minutes < end_minutes:
                            hour = current_minutes // 60
                            minute = current_minutes % 60
                            time_str = f"{hour:02d}:{minute:02d}"
                            
                            # Check if this time slot is in the future (for today only)
                            if day_offset == 0:
                                # Create datetime in Manila timezone for this slot
                                slot_time = datetime.strptime(time_str, "%H:%M").time()
                                slot_datetime_naive = datetime.combine(date, slot_time)
                                
                                # Localize to Manila timezone
                                if hasattr(MANILA_TZ, 'localize'):
                                    # pytz timezone
                                    slot_datetime_manila = MANILA_TZ.localize(slot_datetime_naive)
                                else:
                                    # zoneinfo or timezone offset
                                    slot_datetime_manila = slot_datetime_naive.replace(tzinfo=MANILA_TZ)
                                
                                # Only include if slot is in the future
                                if slot_datetime_manila > now_manila:
                                    if time_str not in all_slots:
                                        all_slots.append(time_str)
                            else:
                                # For future dates, include all slots
                                if time_str not in all_slots:
                                    all_slots.append(time_str)
                            
                            current_minutes += interval
                    
                    if all_slots:
                        time_slots_per_date[date_str] = sorted(all_slots)
                
                return jsonify({
                    "success": True, 
                    "availability": time_slots_per_date,
                    "schedule": availability  # Include original schedule for reference
                }), 200
        
        # Old format: array of date slots (backward compatibility)
        elif isinstance(availability, list):
            return jsonify({"success": True, "availability": availability}), 200
        
        # Empty or invalid format
        else:
            return jsonify({"success": True, "availability": {}}), 200

    except Exception as e:
        print(f"Error fetching doctor availability: {str(e)}")
        return jsonify({"success": False, "error": str(e)}), 500
