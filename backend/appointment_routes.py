"""
Appointments API Routes
Handles appointment scheduling and management
"""

from flask import Blueprint, jsonify, request
from functools import wraps
from datetime import datetime, timedelta
try:
    import pytz
    MANILA_TZ = pytz.timezone('Asia/Manila')
except ImportError:
    # Fallback to zoneinfo for Python 3.9+
    try:
        from zoneinfo import ZoneInfo
        MANILA_TZ = ZoneInfo('Asia/Manila')
    except ImportError:
        # If neither available, use UTC offset (UTC+8)
        from datetime import timezone
        MANILA_TZ = timezone(timedelta(hours=8))

from auth.firebase_auth import firebase_auth_required
from db.supabase_client import SupabaseClient

appointments_bp = Blueprint("appointments", __name__, url_prefix="/api/appointments")
# Initialize Supabase client with error handling
try:
    supabase = SupabaseClient()
    print("âœ… Supabase client initialized for appointments")
except Exception as e:
    print(f"âŒ Error initializing Supabase client for appointments: {e}")
    supabase = None

def get_manila_now():
    """Get current datetime in Asia/Manila timezone"""
    if hasattr(MANILA_TZ, 'localize'):
        # pytz timezone
        return datetime.now(MANILA_TZ)
    else:
        # zoneinfo or timezone offset
        return datetime.now(MANILA_TZ)


def auth_required(f):
    """Decorator that accepts both Firebase and Supabase tokens"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        auth_header = request.headers.get("Authorization")
        
        if not auth_header:
            return jsonify({"error": "No authorization header provided"}), 401
        
        try:
            token = auth_header.split(" ")[1]  # Remove 'Bearer ' prefix
        except IndexError:
            return jsonify({"error": "Invalid authorization header format"}), 401
        
        # Try Firebase token first, but don't fail if it's not a Firebase token
        # IMPORTANT: We MUST try JWT fallbacks if Firebase fails, especially for "kid" claim errors
        from auth.firebase_auth import firebase_auth_service
        firebase_verified = False
        try:
            firebase_result = firebase_auth_service.verify_token(token)
            if firebase_result.get("success"):
                request.firebase_user = firebase_result
                print(f"âœ… Firebase token verified for user: {firebase_result.get('email', 'unknown')}")
                return f(*args, **kwargs)
            else:
                # Firebase verification failed - check if it's a JWT format issue
                error_msg = firebase_result.get('error', '')
                print(f"âš ï¸  Firebase token verification failed: {error_msg}")
                # If it's a "kid" claim error, it's definitely a JWT, not a Firebase token
                if 'kid' in error_msg.lower():
                    print(f"ğŸ” Token is JWT (no 'kid' claim), skipping Firebase and trying JWT fallbacks immediately...")
                    # Skip to JWT fallbacks - don't try Firebase again
                else:
                    print(f"âš ï¸  Firebase verification failed for other reason, trying JWT fallbacks...")
                # Continue to JWT fallbacks - don't return error yet
        except Exception as firebase_error:
            # Firebase verification threw an exception (e.g., "no 'kid' claim"), continue to JWT fallbacks
            error_str = str(firebase_error)
            print(f"âš ï¸  Firebase token verification exception: {error_str}")
            if "kid" in error_str.lower() or "invalid" in error_str.lower() or "malformed" in error_str.lower():
                print(f"ğŸ” Token is not a Firebase token (likely JWT), trying JWT fallbacks...")
            # Continue to try JWT tokens - don't return error yet

        # If Firebase fails, try accepting a Supabase-style JWT (no signature verification in dev)
        try:
            import jwt
            # Decode the JWT without verification (development only)
            decoded = jwt.decode(token, options={"verify_signature": False})

            # Accept Supabase JWTs with sub/email
            if 'sub' in decoded and 'email' in decoded:
                request.firebase_user = {
                    "success": True,
                    "uid": decoded.get('sub'),
                    "email": decoded.get('email')
                }
                print(f"âœ… Supabase JWT accepted for user: {decoded.get('email')}")
                return f(*args, **kwargs)
        except Exception as e:
            print(f"âš ï¸  Token decoding failed (supabase-style): {e}")

        # Finally, accept app-issued JWTs (medichain_token) generated by auth_utils
        try:
            from auth.auth_utils import auth_utils
            print(f"ğŸ” Attempting to decode JWT token (length: {len(token)})...")
            app_payload = auth_utils.decode_token(token)
            print(f"ğŸ” JWT decode result: {app_payload}")
            
            if app_payload and app_payload.get('email'):
                print(f"âœ… JWT decoded successfully for email: {app_payload.get('email')}")
                # The JWT has user_id which is the database ID, not Firebase UID
                # We need to look up the user profile to get the firebase_uid
                user_id = app_payload.get('user_id')
                print(f"ğŸ” JWT user_id: {user_id}")
                
                if user_id and supabase and supabase.service_client:
                    # Look up user profile to get firebase_uid
                    try:
                        print(f"ğŸ” Looking up user profile by id: {user_id}")
                        user_profile_response = (
                            supabase.service_client.table("user_profiles")
                            .select("firebase_uid, email, role")
                            .eq("id", user_id)
                            .execute()
                        )
                        print(f"ğŸ” User profile lookup result: {user_profile_response.data}")
                        
                        if user_profile_response.data:
                            user_profile = user_profile_response.data[0]
                            firebase_uid = user_profile.get('firebase_uid')
                            
                            if firebase_uid:
                                request.firebase_user = {
                                    "success": True,
                                    "uid": firebase_uid,  # Use Firebase UID
                                    "email": app_payload.get('email'),
                                    "role": app_payload.get('role')
                                }
                                print(f"âœ… App JWT accepted for user: {app_payload.get('email')} (firebase_uid: {firebase_uid})")
                                return f(*args, **kwargs)
                            else:
                                print(f"âš ï¸  User profile found but no firebase_uid for user_id: {user_id}")
                        else:
                            # Fallback: try to find by email if user_id lookup fails
                            print(f"ğŸ” User profile not found by id, trying email lookup: {app_payload.get('email')}")
                            user_profile_response = (
                                supabase.service_client.table("user_profiles")
                                .select("firebase_uid, email, role")
                                .eq("email", app_payload.get('email'))
                                .execute()
                            )
                            print(f"ğŸ” User profile lookup by email result: {user_profile_response.data}")
                            
                            if user_profile_response.data:
                                user_profile = user_profile_response.data[0]
                                firebase_uid = user_profile.get('firebase_uid')
                                
                                if firebase_uid:
                                    request.firebase_user = {
                                        "success": True,
                                        "uid": firebase_uid,
                                        "email": app_payload.get('email'),
                                        "role": app_payload.get('role')
                                    }
                                    print(f"âœ… App JWT accepted for user: {app_payload.get('email')} (firebase_uid: {firebase_uid}, found by email)")
                                    return f(*args, **kwargs)
                    except Exception as db_error:
                        print(f"âš ï¸  Database lookup failed for JWT user_id: {db_error}")
                        import traceback
                        traceback.print_exc()
                else:
                    print(f"âš ï¸  Missing user_id ({user_id}) or supabase client not available")
                
                # If we can't find firebase_uid, try using user_id directly (might work if it's actually the firebase_uid)
                uid = app_payload.get('user_id') or app_payload.get('uid') or app_payload.get('sub')
                print(f"âš ï¸  Using direct mapping with uid: {uid}")
                request.firebase_user = {
                    "success": True,
                    "uid": uid,
                    "email": app_payload.get('email'),
                    "role": app_payload.get('role')
                }
                print(f"âœ… App JWT accepted for user: {app_payload.get('email')} (uid: {uid}, using direct mapping)")
                return f(*args, **kwargs)
            else:
                print(f"âš ï¸  JWT decode returned None or missing email: {app_payload}")
        except Exception as e:
            print(f"âš ï¸  App JWT decoding failed: {e}")
            import traceback
            traceback.print_exc()
        
        # If we get here, all token verification methods failed
        print(f"âŒ All token verification methods failed for token (length: {len(token)})")
        print(f"âŒ Token preview: {token[:50]}...")
        return jsonify({
            "error": "Invalid or expired token", 
            "details": "Token could not be verified as Firebase token or JWT. Please ensure you are logged in and try again."
        }), 401
    
    return decorated_function


# Test route to debug
@appointments_bp.route("/test", methods=["GET"])
def test_route():
    """Test route to verify API is working"""
    return jsonify({"success": True, "message": "Appointments API is working"}), 200


@appointments_bp.route("/doctors/approved", methods=["GET"])
@auth_required
def get_approved_doctors():
    """Get list of approved doctors for appointment booking with availability"""
    try:
        print("ğŸ“‹ Fetching approved doctors...")
        # Fetch approved doctors from database using service_client to bypass RLS
        response = (
            supabase.service_client.table("user_profiles")
            .select("id, firebase_uid, first_name, last_name, email, verification_status")
            .eq("role", "doctor")
            .eq("verification_status", "approved")
            .execute()
        )
        print(f"âœ… Found {len(response.data) if response.data else 0} approved doctors")

        if not response.data:
            return jsonify({"success": True, "doctors": [], "message": "No approved doctors available"}), 200

        # Fetch doctor profiles with specializations and availability
        doctors = []
        for user in response.data:
            try:
                # Try to select with is_accepting_appointments first
                try:
                    doctor_profile_response = (
                        supabase.service_client.table("doctor_profiles")
                        .select("specialization, availability, is_accepting_appointments")
                        .eq("firebase_uid", user["firebase_uid"])
                        .execute()
                    )
                except Exception as select_error:
                    # If column doesn't exist, fall back to selecting without it
                    print(f"âš ï¸  Warning: Error selecting is_accepting_appointments: {select_error}")
                    print(f"âš ï¸  Falling back to availability only (assuming is_accepting_appointments = True)")
                doctor_profile_response = (
                    supabase.service_client.table("doctor_profiles")
                    .select("specialization, availability")
                    .eq("firebase_uid", user["firebase_uid"])
                    .execute()
                )
                
                specialization = "General Practitioner"
                availability = []
                has_availability = False
                is_accepting_appointments = True  # Default to True if column doesn't exist
                
                if doctor_profile_response.data and len(doctor_profile_response.data) > 0:
                    specialization = doctor_profile_response.data[0].get("specialization", "General Practitioner")
                    availability_raw = doctor_profile_response.data[0].get("availability", {})
                    
                    # Get is_accepting_appointments from response, default to True if not present
                    is_accepting_appointments = doctor_profile_response.data[0].get("is_accepting_appointments", True)
                    # Handle None/null values and ensure it's a boolean
                    if is_accepting_appointments is None:
                        is_accepting_appointments = True
                    # Convert to boolean if it's stored as string or other type
                    if isinstance(is_accepting_appointments, str):
                        is_accepting_appointments = is_accepting_appointments.lower() in ('true', '1', 'yes', 'on')
                    else:
                        is_accepting_appointments = bool(is_accepting_appointments)
                    
                    # CRITICAL: If doctor is not accepting appointments, they have NO availability regardless of time ranges
                    if not is_accepting_appointments:
                        has_availability = False
                        print(f"ğŸš« Doctor {user.get('email')}: NOT accepting appointments - has_availability = False")
                    else:
                        # Debug logging
                        print(f"ğŸ” Doctor {user.get('email')}: availability_raw type = {type(availability_raw)}")
                        print(f"ğŸ” Doctor {user.get('email')}: availability_raw = {availability_raw}")
                        print(f"ğŸ” Doctor {user.get('email')}: is_accepting_appointments = {is_accepting_appointments}")
                        
                        # Check availability based on format
                        # New format: { time_ranges: [{ start_time, end_time, interval }, ...] }
                        # Old format: [{ date: "...", time_slots: [...] }, ...]
                        if isinstance(availability_raw, dict) and availability_raw:
                            # New format with time_ranges
                            if "time_ranges" in availability_raw and isinstance(availability_raw["time_ranges"], list):
                                print(f"ğŸ” Doctor {user.get('email')}: Found time_ranges with {len(availability_raw['time_ranges'])} ranges")
                                if len(availability_raw["time_ranges"]) > 0:
                                    # Doctor is accepting appointments AND has time_ranges defined
                                    has_availability = True
                                    print(f"âœ… Doctor {user.get('email')}: has_availability = True (has time_ranges, accepting={is_accepting_appointments})")
                                else:
                                    print(f"âŒ Doctor {user.get('email')}: has_availability = False (empty time_ranges)")
                                availability = availability_raw  # Store the raw availability object
                            # Legacy single range format: { start_time, end_time, interval }
                            elif "start_time" in availability_raw and "end_time" in availability_raw:
                                print(f"âœ… Doctor {user.get('email')}: Found legacy format, converting to time_ranges")
                                # Convert to time_ranges format for consistency
                                availability = {
                                    "time_ranges": [{
                                        "start_time": availability_raw.get("start_time", "07:00"),
                                        "end_time": availability_raw.get("end_time", "17:00"),
                                        "interval": availability_raw.get("interval", 30)
                                    }]
                                }
                                has_availability = True  # Doctor is accepting and has time range
                            else:
                                print(f"âŒ Doctor {user.get('email')}: Dict format but no time_ranges or start_time/end_time found")
                        elif isinstance(availability_raw, list) and len(availability_raw) > 0:
                            print(f"ğŸ” Doctor {user.get('email')}: Found list format (old format)")
                            # Old format: array of date slots
                            availability = availability_raw
                            # Check if any slots are in the future
                            today = datetime.now().date()
                            for slot in availability_raw:
                                if isinstance(slot, dict) and "date" in slot:
                                    slot_date = datetime.strptime(slot["date"], "%Y-%m-%d").date()
                                    if slot_date >= today and slot.get("time_slots"):
                                        has_availability = True  # Doctor is accepting and has future slots
                                        break
                        else:
                            print(f"âŒ Doctor {user.get('email')}: availability_raw is empty or invalid: {type(availability_raw)}")
                        
                        print(f"ğŸ” Doctor {user.get('email')}: Final has_availability = {has_availability}, is_accepting_appointments = {is_accepting_appointments}")
            except Exception as profile_error:
                print(f"âš ï¸  Error fetching profile for {user.get('email')}: {profile_error}")
                import traceback
                traceback.print_exc()
                # Continue with default values if profile fetch fails
                specialization = "General Practitioner"
                availability = []
                has_availability = False
                is_accepting_appointments = True

            doctors.append(
                {
                    "id": user["id"],
                    "firebase_uid": user["firebase_uid"],
                    "name": f"{user.get('first_name', '')} {user.get('last_name', '')}".strip(),
                    "first_name": user.get("first_name", ""),
                    "last_name": user.get("last_name", ""),
                    "email": user.get("email", ""),
                    "specialization": specialization,
                    "verification_status": user.get("verification_status", "approved"),
                    "availability": availability,
                    "has_availability": has_availability,
                }
            )

        print(f"âœ… Returning {len(doctors)} doctors")
        return jsonify({"success": True, "doctors": doctors, "count": len(doctors)}), 200

    except Exception as e:
        print(f"Error fetching approved doctors: {str(e)}")
        return jsonify({"success": False, "error": "Failed to fetch doctors", "message": str(e)}), 500


@appointments_bp.route("", methods=["GET"])
@auth_required
def get_appointments():
    """Get user's appointments"""
    try:
        firebase_user = request.firebase_user
        uid = firebase_user["uid"]

        # Get user profile to determine role - use service_client to bypass RLS
        user_response = supabase.service_client.table("user_profiles").select("role").eq("firebase_uid", uid).execute()
        if not user_response.data:
            return jsonify({"success": False, "error": "User profile not found"}), 404

        user_role = user_response.data[0]["role"]

        if user_role == "patient":
            # Patients see their own appointments - use service_client to bypass RLS
            response = supabase.service_client.table("appointments").select("*").eq("patient_firebase_uid", uid).execute()
            # Enrich with doctor info for patients
            if response.data:
                try:
                    doctor_uids = sorted({appt.get("doctor_firebase_uid") for appt in response.data if appt.get("doctor_firebase_uid")})
                    if doctor_uids:
                        profiles_resp = (
                            supabase.service_client
                            .table("user_profiles")
                            .select("firebase_uid, first_name, last_name, email")
                            .in_("firebase_uid", doctor_uids)
                            .execute()
                        )
                        uid_to_doctor = {p["firebase_uid"]: {
                            "first_name": p.get("first_name", ""),
                            "last_name": p.get("last_name", ""),
                            "email": p.get("email", "")
                        } for p in (profiles_resp.data or [])}
                        for appt in response.data:
                            dfuid = appt.get("doctor_firebase_uid")
                            if dfuid and dfuid in uid_to_doctor:
                                appt["doctor"] = uid_to_doctor[dfuid]
                except Exception as _e:
                    print(f"âš ï¸  Error enriching doctor info: {_e}")
                    pass
        elif user_role == "doctor":
            # Doctors see their appointments - use service_client to bypass RLS
            response = supabase.service_client.table("appointments").select("*").eq("doctor_firebase_uid", uid).execute()
            # Enrich with basic patient info for schedule views
            if response.data:
                try:
                    patient_uids = sorted({appt.get("patient_firebase_uid") for appt in response.data if appt.get("patient_firebase_uid")})
                    print(f"ğŸ” Doctor appointments: Found {len(patient_uids)} unique patient UIDs: {patient_uids}")
                    if patient_uids:
                        profiles_resp = (
                            supabase.service_client
                            .table("user_profiles")
                            .select("firebase_uid, first_name, last_name, email")
                            .in_("firebase_uid", patient_uids)
                            .execute()
                        )
                        print(f"ğŸ” Doctor appointments: Fetched {len(profiles_resp.data or [])} patient profiles")
                        uid_to_patient = {}
                        for p in (profiles_resp.data or []):
                            # Get values, handling None, empty strings, and whitespace
                            first_name = (p.get("first_name") or "").strip() if p.get("first_name") else ""
                            last_name = (p.get("last_name") or "").strip() if p.get("last_name") else ""
                            email = (p.get("email") or "").strip() if p.get("email") else ""
                            
                            # Check if all fields are empty - this indicates incomplete profile
                            if not first_name and not last_name and not email:
                                print(f"âš ï¸  Patient profile {p['firebase_uid']} exists but ALL fields are empty - will try Firebase Auth fallback")
                                # Don't add to cache yet - we'll try Firebase Auth fallback during enrichment
                                continue
                            
                            uid_to_patient[p["firebase_uid"]] = {
                                "first_name": first_name,
                                "last_name": last_name,
                                "email": email
                            }
                            
                            full_name = f"{first_name} {last_name}".strip()
                            print(f"âœ… Patient profile: {p['firebase_uid']} -> Name: '{full_name}' Email: '{email}'")
                            if not full_name and email:
                                print(f"   âš ï¸  Profile has email but no name - will use email for display")
                            elif not full_name and not email:
                                print(f"   âŒ Profile exists but has NO name and NO email!")
                        
                        # Enrich each appointment with patient info
                        for appt in response.data:
                            pfuid = appt.get("patient_firebase_uid")
                            if pfuid:
                                # Check if patient is in cache (has valid data) or needs Firebase Auth fallback
                                if pfuid in uid_to_patient:
                                    patient_info = uid_to_patient[pfuid]
                                    first_name = patient_info.get("first_name") or ""
                                    last_name = patient_info.get("last_name") or ""
                                    email = patient_info.get("email") or ""
                                    full_name = f"{first_name} {last_name}".strip()
                                    
                                    appt["patient"] = patient_info
                                    if full_name or email:
                                        print(f"âœ… Enriched appointment {appt.get('id')} with patient: Name='{full_name}' Email='{email}'")
                                    else:
                                        print(f"âš ï¸  Appointment {appt.get('id')}: Patient in cache but has no name/email - will try Firebase Auth")
                                        # Fall through to Firebase Auth fallback below
                                else:
                                    # Patient not in cache - either doesn't exist or was skipped due to empty fields
                                    print(f"âš ï¸  Appointment {appt.get('id')}: Patient UID {pfuid} not in cache (missing or empty profile)")
                                
                                # Check if we need Firebase Auth fallback
                                needs_fallback = False
                                if pfuid not in uid_to_patient:
                                    needs_fallback = True
                                    print(f"ğŸ”„ Patient UID {pfuid} not in cache - needs Firebase Auth fallback")
                                else:
                                    cached_patient = uid_to_patient.get(pfuid, {})
                                    cached_fname = cached_patient.get("first_name", "") or ""
                                    cached_email = cached_patient.get("email", "") or ""
                                    if not cached_fname.strip() and not cached_email.strip():
                                        needs_fallback = True
                                        print(f"ğŸ”„ Patient UID {pfuid} in cache but has empty data - needs Firebase Auth fallback")
                                
                                # If patient info is missing or empty, try Firebase Auth fallback
                                if needs_fallback:
                                    print(f"ğŸ”„ Attempting Firebase Auth fallback for patient UID: {pfuid}")
                                    try:
                                        from auth.firebase_auth import firebase_auth_service
                                        print(f"ğŸ” Calling Firebase Auth service for UID: {pfuid}")
                                        firebase_result = firebase_auth_service.get_user_by_uid(pfuid)
                                        print(f"ğŸ” Firebase Auth result: success={firebase_result.get('success')}, has_user={bool(firebase_result.get('user'))}")
                                        
                                        if firebase_result.get("success") and firebase_result.get("user"):
                                            firebase_user = firebase_result["user"]
                                            firebase_email = firebase_user.get("email", "") or ""
                                            firebase_display_name = firebase_user.get("display_name", "") or ""
                                            
                                            print(f"ğŸ” Firebase user data: email='{firebase_email}', display_name='{firebase_display_name}'")
                                            
                                            # Extract name from Firebase
                                            if firebase_display_name:
                                                name_parts = firebase_display_name.split(" ", 1)
                                                first_name = name_parts[0]
                                                last_name = name_parts[1] if len(name_parts) > 1 else ""
                                            elif firebase_email:
                                                first_name = firebase_email.split("@")[0]
                                                last_name = ""
                                            else:
                                                first_name = ""
                                                last_name = ""
                                            
                                            # Create patient info from Firebase data
                                            patient_info = {
                                                "first_name": first_name or "",
                                                "last_name": last_name or "",
                                                "email": firebase_email or ""
                                            }
                                            
                                            # Update cache
                                            uid_to_patient[pfuid] = patient_info
                                            appt["patient"] = patient_info
                                            
                                            full_name = f"{first_name} {last_name}".strip()
                                            print(f"âœ… Fetched patient data from Firebase Auth: Name='{full_name}' Email='{firebase_email}'")
                                            
                                            # Update database profile for future requests
                                            try:
                                                update_data = {
                                                    "first_name": first_name or "",
                                                    "last_name": last_name or "",
                                                    "email": firebase_email or ""
                                                }
                                                supabase.service_client.table("user_profiles").update(update_data).eq("firebase_uid", pfuid).execute()
                                                print(f"âœ… Updated patient profile in database with Firebase Auth data")
                                            except Exception as update_error:
                                                print(f"âš ï¸  Could not update patient profile: {update_error}")
                                                import traceback
                                                traceback.print_exc()
                                        else:
                                            error_msg = firebase_result.get("error", "Unknown error") if firebase_result else "No response"
                                            print(f"âŒ Firebase Auth lookup failed for {pfuid}: {error_msg}")
                                            print(f"   Full Firebase result: {firebase_result}")
                                            # Set empty patient object as last resort
                                            if "patient" not in appt:
                                                appt["patient"] = {
                                                    "first_name": "",
                                                    "last_name": "",
                                                    "email": ""
                                                }
                                    except Exception as firebase_fallback_error:
                                        print(f"âŒ Error in Firebase Auth fallback: {firebase_fallback_error}")
                                        import traceback
                                        traceback.print_exc()
                                        # Set empty patient object as last resort
                                        if "patient" not in appt:
                                            appt["patient"] = {
                                                "first_name": "",
                                                "last_name": "",
                                                "email": ""
                                            }
                            else:
                                print(f"âš ï¸  Appointment {appt.get('id')}: No patient_firebase_uid found in appointment record")
                                # Add empty patient object
                                appt["patient"] = {
                                    "first_name": "",
                                    "last_name": "",
                                    "email": ""
                                }
                except Exception as _e:
                    # If enrichment fails, continue with base data
                    print(f"âš ï¸  Error enriching patient info: {_e}")
                    import traceback
                    traceback.print_exc()
                    # Still add empty patient objects to prevent frontend errors
                    for appt in response.data:
                        if "patient" not in appt:
                            appt["patient"] = {
                                "first_name": "",
                                "last_name": "",
                                "email": ""
                            }
                    pass
        else:
            return jsonify({"success": False, "error": "Unauthorized role"}), 403

        # Enrich appointments with meeting_url from meeting_link column or notes fallback
        enriched = []
        for appt in (response.data or []):
            try:
                # First try meeting_link column (preferred)
                meeting_url = appt.get("meeting_link")
                
                # Fallback to parsing from notes if meeting_link is not available
                if not meeting_url:
                    notes = appt.get("notes") or ""
                    for line in str(notes).splitlines():
                        if "Meeting:" in line and "http" in line:
                            meeting_url = line.split("Meeting:", 1)[1].strip()
                            break
                
                if meeting_url:
                    appt["meeting_url"] = meeting_url
                
                # Final verification: Log patient data being sent to frontend
                patient = appt.get("patient", {})
                patient_fname = patient.get("first_name", "")
                patient_lname = patient.get("last_name", "")
                patient_email = patient.get("email", "")
                patient_full = f"{patient_fname} {patient_lname}".strip()
                
                if patient_full or patient_email:
                    print(f"ğŸ“¤ Sending appointment {appt.get('id')} with patient: Name='{patient_full}' Email='{patient_email}'")
                else:
                    print(f"âš ï¸  WARNING: Sending appointment {appt.get('id')} with EMPTY patient data! UID: {appt.get('patient_firebase_uid')}")
                    print(f"   Patient object: {patient}")
            except Exception as enrich_error:
                print(f"âŒ Error enriching appointment {appt.get('id')}: {enrich_error}")
                import traceback
                traceback.print_exc()
            enriched.append(appt)

        return jsonify({"success": True, "appointments": enriched}), 200

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@appointments_bp.route("", methods=["POST"])
@auth_required
def create_appointment():
    """Create a new appointment and remove booked time from doctor availability"""
    try:
        firebase_user = request.firebase_user
        uid = firebase_user["uid"]
        data = request.get_json()

        # Validate required fields
        required_fields = ["doctor_firebase_uid", "appointment_date", "appointment_time"]
        for field in required_fields:
            if field not in data:
                return (
                    jsonify({"success": False, "error": f"Missing required field: {field}"}),
                    400,
                )

        # Get user role and profile info - use service_client to bypass RLS
        user_response = supabase.service_client.table("user_profiles").select("role, first_name, last_name, email").eq("firebase_uid", uid).execute()
        if not user_response.data:
            return jsonify({"success": False, "error": "User profile not found"}), 404

        user_role = user_response.data[0]["role"]

        if user_role != "patient":
            return jsonify({"success": False, "error": "Only patients can book appointments"}), 403

        # Check if the time slot is available in doctor's availability - use service_client to bypass RLS
        doctor_profile = (
            supabase.service_client.table("doctor_profiles")
            .select("availability")
            .eq("firebase_uid", data["doctor_firebase_uid"])
            .execute()
        )

        if not doctor_profile.data:
            return jsonify({"success": False, "error": "Doctor not found"}), 404

        availability = doctor_profile.data[0].get("availability", {})
        appointment_date = data["appointment_date"]
        appointment_time = data["appointment_time"]

        # Check availability based on format
        # New format: { time_ranges: [{ start_time, end_time, interval }, ...] }
        # or legacy single range: { start_time, end_time, interval }
        if isinstance(availability, dict):
            time_ranges = []
            # Check for new format with time_ranges array
            if "time_ranges" in availability and isinstance(availability["time_ranges"], list):
                time_ranges = availability["time_ranges"]
            # Legacy single range format
            elif "start_time" in availability:
                time_ranges = [{
                    "start_time": availability.get("start_time", "07:00"),
                    "end_time": availability.get("end_time", "17:00"),
                    "interval": availability.get("interval", 30)
                }]
            
            if time_ranges:
                # Parse appointment time
                try:
                    appt_hour, appt_min = map(int, appointment_time.split(":"))
                    appt_minutes = appt_hour * 60 + appt_min
                except ValueError:
                    return jsonify({"success": False, "error": "Invalid appointment time format"}), 400
                
                # Check if appointment time matches any range
                time_found = False
                for time_range in time_ranges:
                    start_hour, start_min = map(int, time_range["start_time"].split(":"))
                    end_hour, end_min = map(int, time_range["end_time"].split(":"))
                    start_minutes = start_hour * 60 + start_min
                    end_minutes = end_hour * 60 + end_min
                    interval = time_range.get("interval", 30)
                    
                    # Check if time is within this range
                    if appt_minutes >= start_minutes and appt_minutes < end_minutes:
                        # Check if time matches interval
                        relative_minutes = appt_minutes - start_minutes
                        if relative_minutes % interval == 0:
                            time_found = True
                            break
                
                if not time_found:
                    return jsonify({"success": False, "error": "Selected time is outside doctor's availability hours or doesn't match the interval"}), 400
                
                # Check if appointment time is in the past (using Manila timezone)
                try:
                    now_manila = get_manila_now()
                    slot_datetime_naive = datetime.strptime(f"{appointment_date} {appointment_time}", "%Y-%m-%d %H:%M")
                    
                    # Localize to Manila timezone
                    if hasattr(MANILA_TZ, 'localize'):
                        # pytz timezone
                        slot_datetime_manila = MANILA_TZ.localize(slot_datetime_naive)
                    else:
                        # zoneinfo or timezone offset
                        slot_datetime_manila = slot_datetime_naive.replace(tzinfo=MANILA_TZ)
                    
                    if slot_datetime_manila <= now_manila:
                        return jsonify({"success": False, "error": "Cannot book appointments in the past"}), 400
                except ValueError:
                    return jsonify({"success": False, "error": "Invalid date or time format"}), 400
        
        # Old format: array of date slots
        elif isinstance(availability, list):
            date_slot = next((slot for slot in availability if slot.get("date") == appointment_date), None)
            
            if not date_slot or appointment_time not in date_slot.get("time_slots", []):
                return jsonify({"success": False, "error": "Selected time slot is not available"}), 400
        
        # No availability set
        else:
            return jsonify({"success": False, "error": "Doctor has not set availability"}), 400

        # Check if appointment already exists for this time slot - use service_client to bypass RLS
        existing_appointment = (
            supabase.service_client.table("appointments")
            .select("id")
            .eq("doctor_firebase_uid", data["doctor_firebase_uid"])
            .eq("appointment_date", appointment_date)
            .eq("appointment_time", appointment_time)
            .eq("status", "scheduled")
            .execute()
        )

        if existing_appointment.data:
            return jsonify({"success": False, "error": "This time slot has already been booked"}), 400

        # Create Jitsi meeting details
        import uuid
        safe_date = appointment_date.replace("-", "")
        safe_time = appointment_time.replace(":", "")
        room_suffix = uuid.uuid4().hex[:8]
        room_name = f"medichain-{data['doctor_firebase_uid']}-{safe_date}-{safe_time}-{room_suffix}"
        meeting_url = f"https://meet.jit.si/{room_name}#config.prejoinPageEnabled=true"

        # Get patient and doctor names for notifications
        patient_profile = user_response.data[0]
        patient_first_name = (patient_profile.get('first_name') or "").strip() if patient_profile.get('first_name') else ""
        patient_last_name = (patient_profile.get('last_name') or "").strip() if patient_profile.get('last_name') else ""
        patient_email = (patient_profile.get('email') or "").strip() if patient_profile.get('email') else ""
        patient_name = f"{patient_first_name} {patient_last_name}".strip()
        
        # Ensure patient profile has email (required for display)
        if not patient_name:
            if patient_email:
                patient_name = patient_email.split('@')[0] or patient_email
            else:
                patient_name = "Patient"
        
        # If patient profile is missing name/email, update it (ensure data consistency)
        if not patient_first_name and not patient_last_name:
            print(f"âš ï¸  WARNING: Patient profile for UID {uid} has no name. Email: {patient_email}")
        
        doctor_profile_response = (
            supabase.service_client.table("user_profiles")
            .select("first_name, last_name")
            .eq("firebase_uid", data["doctor_firebase_uid"])
            .execute()
        )
        doctor_name = "Doctor"
        if doctor_profile_response.data:
            doctor_profile = doctor_profile_response.data[0]
            doctor_name = f"Dr. {doctor_profile.get('first_name', '')} {doctor_profile.get('last_name', '')}".strip()

        # Create the appointment with meeting_link properly stored
        appointment_data = {
            "patient_firebase_uid": uid,
            "doctor_firebase_uid": data["doctor_firebase_uid"],
            "appointment_date": appointment_date,
            "appointment_time": appointment_time,
            "appointment_type": data.get("appointment_type", "consultation"),
            "meeting_link": meeting_url,  # Store in meeting_link column
            "notes": data.get("notes", "").strip(),
            "status": "scheduled"
        }

        # Use service_client to bypass RLS policies when inserting appointments
        response = supabase.service_client.table("appointments").insert(appointment_data).execute()

        if not response.data:
            return jsonify({"success": False, "error": "Failed to create appointment"}), 500
        
        appointment_id = response.data[0].get("id")

        # For old format only: Remove the booked time slot from doctor's availability
        # New format doesn't need this since availability is schedule-based
        if isinstance(availability, list):
            updated_availability = []
            for slot in availability:
                if slot["date"] == appointment_date:
                    # Remove the booked time
                    remaining_times = [t for t in slot["time_slots"] if t != appointment_time]
                    # Only keep the date if there are remaining time slots
                    if remaining_times:
                        updated_availability.append({
                            "date": slot["date"],
                            "time_slots": remaining_times
                        })
                else:
                    updated_availability.append(slot)

            # Update doctor's availability (old format only) - use service_client to bypass RLS
            supabase.service_client.table("doctor_profiles").update({
                "availability": updated_availability
            }).eq("firebase_uid", data["doctor_firebase_uid"]).execute()

        # Create notifications for both patient and doctor
        try:
            from services.notification_service import notification_service
            
            # Extract room name from meeting URL for frontend routing
            room_name = room_name  # Already defined above
            
            # Create appointment notifications with video call info
            # Patient notification
            notification_service.create_appointment_notification(
                user_id=uid,
                appointment_id=appointment_id,
                appointment_date=appointment_date,
                appointment_time=appointment_time,
                doctor_name=doctor_name,
                notification_type='appointment_created',
                meeting_url=meeting_url
            )
            
            # Also send video call ready notification for patient
            notification_service.create_video_call_notification(
                user_id=uid,
                appointment_id=appointment_id,
                appointment_date=appointment_date,
                appointment_time=appointment_time,
                doctor_name=doctor_name,
                meeting_url=meeting_url,
                notification_type='video_call_ready'
            )
            
            # Doctor notification
            notification_service.create_appointment_notification(
                user_id=data["doctor_firebase_uid"],
                appointment_id=appointment_id,
                appointment_date=appointment_date,
                appointment_time=appointment_time,
                patient_name=patient_name,
                notification_type='appointment_created',
                meeting_url=meeting_url
            )
            
            # Also send video call ready notification for doctor
            notification_service.create_video_call_notification(
                user_id=data["doctor_firebase_uid"],
                appointment_id=appointment_id,
                appointment_date=appointment_date,
                appointment_time=appointment_time,
                patient_name=patient_name,
                meeting_url=meeting_url,
                notification_type='video_call_ready'
            )
            
            print(f"ğŸ”” Notifications created for appointment {appointment_id}. Meeting URL: {meeting_url}")
            print(f"ğŸ“¹ Video call notifications sent to both patient and doctor")
        except Exception as e:
            print(f"âš ï¸  Error creating notifications: {e}")
            import traceback
            traceback.print_exc()
            # Don't fail the appointment creation if notifications fail

        return (
            jsonify(
                {
                    "success": True,
                    "appointment": response.data[0] if response.data else None,
                    "message": "Appointment booked successfully!",
                    "meeting_url": meeting_url,
                }
            ),
            201,
        )

    except Exception as e:
        print(f"Error creating appointment: {str(e)}")
        return jsonify({"success": False, "error": str(e)}), 500


@appointments_bp.route("/<appointment_id>", methods=["PUT"])
@firebase_auth_required
def update_appointment(appointment_id):
    """Update an appointment"""
    try:
        firebase_user = request.firebase_user
        uid = firebase_user["uid"]
        data = request.get_json()

        # Update appointment (RLS ensures users can only update their own appointments)
        response = (
            supabase.client.table("appointments")
            .update(data)
            .eq("id", appointment_id)
            .or_(f"patient_firebase_uid.eq.{uid},doctor_firebase_uid.eq.{uid}")
            .execute()
        )

        if response.data:
            return jsonify({"success": True, "appointment": response.data[0]}), 200
        else:
            return jsonify({"success": False, "error": "Appointment not found or unauthorized"}), 404

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


# Doctor Availability Routes
@appointments_bp.route("/availability", methods=["GET"])
@auth_required
def get_doctor_availability():
    """Get current doctor's availability schedule"""
    try:
        firebase_user = request.firebase_user
        uid = firebase_user["uid"]

        # Verify user is a doctor - use service_client to bypass RLS
        user_response = supabase.service_client.table("user_profiles").select("role").eq("firebase_uid", uid).execute()
        if not user_response.data or user_response.data[0]["role"] != "doctor":
            return jsonify({"success": False, "error": "Only doctors can access this endpoint"}), 403

        # Get doctor's availability and accepting status (handle gracefully if column doesn't exist)
        # Use service_client to bypass RLS
        try:
            response = (
                supabase.service_client.table("doctor_profiles")
                .select("availability, is_accepting_appointments")
                .eq("firebase_uid", uid)
                .execute()
            )
        except Exception as select_error:
            # If column doesn't exist, try without it
            print(f"âš ï¸  Warning: Error selecting is_accepting_appointments: {select_error}")
            print(f"âš ï¸  Falling back to availability only (assuming is_accepting_appointments = True)")
            response = (
                supabase.service_client.table("doctor_profiles")
                .select("availability")
                .eq("firebase_uid", uid)
                .execute()
            )
        
        if not response.data:
            return jsonify({"success": False, "error": "Doctor profile not found"}), 404

        availability = response.data[0].get("availability", {})
        # Get is_accepting_appointments - check if it exists in the response
        # CRITICAL: Use a sentinel value to distinguish between "key doesn't exist" and "value is False"
        is_accepting_appointments_raw = response.data[0].get("is_accepting_appointments")
        column_exists = "is_accepting_appointments" in response.data[0]
        
        print(f"ğŸ” GET /availability: Doctor {uid}")
        print(f"ğŸ” GET: column_exists = {column_exists}")
        print(f"ğŸ” GET: is_accepting_appointments_raw = {is_accepting_appointments_raw} (type: {type(is_accepting_appointments_raw)})")
        print(f"ğŸ” GET: is_accepting_appointments_raw is None? {is_accepting_appointments_raw is None}")
        print(f"ğŸ” GET: is_accepting_appointments_raw == False? {is_accepting_appointments_raw == False}")
        print(f"ğŸ” GET: is_accepting_appointments_raw is False? {is_accepting_appointments_raw is False}")
        
        # CRITICAL: Only default to True if the value is truly missing (not in response) or NULL
        # If it's False, we MUST preserve False
        if not column_exists:
            # Column doesn't exist or wasn't selected - default to True
            is_accepting_appointments = True
            print(f"âš ï¸  GET /availability: is_accepting_appointments column not found, defaulting to True")
        elif is_accepting_appointments_raw is None:
            # Column exists but value is NULL
            # CRITICAL: After removing DEFAULT TRUE, NULL should only happen if never set
            # But to be safe, we'll check if this is a new doctor profile
            # For now, default to True only if NULL (meaning never explicitly set)
            # If it was explicitly set to False, it should be False, not NULL
            is_accepting_appointments = True
            print(f"âš ï¸  GET /availability: is_accepting_appointments is NULL (never set), defaulting to True")
        else:
            # Value exists (could be False or True) - convert to boolean properly, preserving False
            if isinstance(is_accepting_appointments_raw, str):
                is_accepting_appointments = is_accepting_appointments_raw.lower() in ('true', '1', 'yes', 'on')
                print(f"ğŸ”„ GET: Converted string '{is_accepting_appointments_raw}' to boolean: {is_accepting_appointments}")
            else:
                # Use bool() which correctly converts False to False and True to True
                is_accepting_appointments = bool(is_accepting_appointments_raw)
                print(f"âœ… GET: Converted {is_accepting_appointments_raw} (type: {type(is_accepting_appointments_raw)}) to boolean: {is_accepting_appointments}")
        
        print(f"ğŸ” GET /availability: Doctor {uid}, FINAL is_accepting_appointments = {is_accepting_appointments} (raw: {is_accepting_appointments_raw}, column_exists: {column_exists}, type: {type(is_accepting_appointments_raw)})")
        
        return jsonify({
            "success": True, 
            "availability": availability,
            "is_accepting_appointments": is_accepting_appointments
        }), 200

    except Exception as e:
        print(f"Error fetching availability: {str(e)}")
        return jsonify({"success": False, "error": str(e)}), 500


@appointments_bp.route("/availability", methods=["PUT"])
@auth_required
def update_doctor_availability():
    """Update doctor's availability schedule (new format: time range + interval)"""
    try:
        firebase_user = request.firebase_user
        uid = firebase_user["uid"]
        data = request.get_json()
        
        print(f"DEBUG: Received availability update request from user {uid}")
        print(f"DEBUG: Request data: {data}")
        print(f"DEBUG: Request Content-Type: {request.content_type}")
        
        if data is None:
            return jsonify({"success": False, "error": "Invalid request. JSON data is required."}), 400
        
        # Check if Supabase client is available
        if supabase is None or supabase.client is None:
            print("ERROR: Supabase client is not initialized")
            return jsonify({"success": False, "error": "Database connection failed. Please try again later."}), 500

        # Verify user is a doctor - use service_client to bypass RLS
        user_response = supabase.service_client.table("user_profiles").select("role").eq("firebase_uid", uid).execute()
        if not user_response.data or user_response.data[0]["role"] != "doctor":
            return jsonify({"success": False, "error": "Only doctors can update availability"}), 403

        # Validate availability data - support both old format (array) and new format (object)
        availability = data.get("availability", {})
        
        if not availability:
            return jsonify({"success": False, "error": "Availability data is required"}), 400
        
        print(f"DEBUG: Availability data: {availability}")
        print(f"DEBUG: Availability type: {type(availability)}")
        
        # New format: { time_ranges: [{ start_time, end_time, interval }, ...] }
        # or legacy single range: { start_time, end_time, interval }
        if isinstance(availability, dict):
            # Check for new format with time_ranges array
            if "time_ranges" in availability and isinstance(availability["time_ranges"], list):
                if len(availability["time_ranges"]) == 0:
                    return jsonify({"success": False, "error": "At least one time range is required"}), 400
                
                # Validate each time range
                for i, time_range in enumerate(availability["time_ranges"]):
                    if not isinstance(time_range, dict):
                        return jsonify({"success": False, "error": f"Time range {i+1} must be an object"}), 400
                    
                    if "start_time" not in time_range or "end_time" not in time_range or "interval" not in time_range:
                        return jsonify({"success": False, "error": f"Time range {i+1} must include start_time, end_time, and interval"}), 400
                    
                    # Validate time format
                    try:
                        datetime.strptime(time_range["start_time"], "%H:%M")
                        datetime.strptime(time_range["end_time"], "%H:%M")
                    except ValueError:
                        return jsonify({"success": False, "error": f"Time range {i+1}: Invalid time format. Use HH:MM"}), 400
                    
                    # Validate interval
                    interval = time_range.get("interval")
                    if interval is None:
                        return jsonify({"success": False, "error": f"Time range {i+1}: Interval is required"}), 400
                    
                    # Convert interval to int if it's a string
                    try:
                        interval = int(interval)
                    except (ValueError, TypeError):
                        return jsonify({"success": False, "error": f"Time range {i+1}: Interval must be a number"}), 400
                    
                    if interval not in [15, 25, 30]:
                        return jsonify({"success": False, "error": f"Time range {i+1}: Interval must be 15, 25, or 30 minutes"}), 400
                    
                    # Validate end time is after start time
                    start_hour, start_min = map(int, time_range["start_time"].split(":"))
                    end_hour, end_min = map(int, time_range["end_time"].split(":"))
                    start_minutes = start_hour * 60 + start_min
                    end_minutes = end_hour * 60 + end_min
                    
                    if end_minutes <= start_minutes:
                        return jsonify({"success": False, "error": f"Time range {i+1}: End time must be after start time"}), 400
                
                # Check for overlaps between ranges
                for i in range(len(availability["time_ranges"])):
                    for j in range(i + 1, len(availability["time_ranges"])):
                        range1 = availability["time_ranges"][i]
                        range2 = availability["time_ranges"][j]
                        
                        start1_hour, start1_min = map(int, range1["start_time"].split(":"))
                        end1_hour, end1_min = map(int, range1["end_time"].split(":"))
                        start2_hour, start2_min = map(int, range2["start_time"].split(":"))
                        end2_hour, end2_min = map(int, range2["end_time"].split(":"))
                        
                        start1_minutes = start1_hour * 60 + start1_min
                        end1_minutes = end1_hour * 60 + end1_min
                        start2_minutes = start2_hour * 60 + start2_min
                        end2_minutes = end2_hour * 60 + end2_min
                        
                        # Check if ranges overlap
                        if not (end1_minutes <= start2_minutes or start1_minutes >= end2_minutes):
                            return jsonify({"success": False, "error": f"Time ranges {i+1} and {j+1} overlap. Please adjust them."}), 400
            
            # Legacy single range format: { start_time, end_time, interval }
            elif "start_time" in availability and "end_time" in availability:
                # Validate time format
                try:
                    datetime.strptime(availability["start_time"], "%H:%M")
                    datetime.strptime(availability["end_time"], "%H:%M")
                except ValueError:
                    return jsonify({"success": False, "error": "Invalid time format. Use HH:MM"}), 400
                
                # Validate interval
                if availability.get("interval") not in [15, 25, 30]:
                    return jsonify({"success": False, "error": "Interval must be 15, 25, or 30 minutes"}), 400
                
                # Validate end time is after start time
                start_hour, start_min = map(int, availability["start_time"].split(":"))
                end_hour, end_min = map(int, availability["end_time"].split(":"))
                start_minutes = start_hour * 60 + start_min
                end_minutes = end_hour * 60 + end_min
                
                if end_minutes <= start_minutes:
                    return jsonify({"success": False, "error": "End time must be after start time"}), 400
            
            else:
                return jsonify({"success": False, "error": "Availability must include time_ranges array or start_time/end_time/interval"}), 400
        
        # Old format: array of date slots (keep for backward compatibility)
        elif isinstance(availability, list):
            if not all(isinstance(slot, dict) and "date" in slot and "time_slots" in slot for slot in availability):
                return jsonify({"success": False, "error": "Invalid availability format"}), 400

        # Get is_accepting_appointments from request (optional, defaults to True if not provided)
        is_accepting_appointments_raw = data.get("is_accepting_appointments")
        
        # CRITICAL: Handle the case where the value might not be provided
        # If not provided, we should keep the existing value, but for now we'll default to True
        # However, if False is explicitly sent, we MUST preserve it
        if is_accepting_appointments_raw is None:
            # Not provided in request - default to True
            is_accepting_appointments = True
        else:
            # Value provided - convert to boolean properly, preserving False
            if isinstance(is_accepting_appointments_raw, str):
                is_accepting_appointments = is_accepting_appointments_raw.lower() in ('true', '1', 'yes', 'on')
            else:
                # Use bool() which correctly converts False to False and True to True
                is_accepting_appointments = bool(is_accepting_appointments_raw)
        
        print(f"ğŸ”„ PUT /availability: Doctor {uid}, is_accepting_appointments = {is_accepting_appointments} (raw: {is_accepting_appointments_raw}, type: {type(is_accepting_appointments_raw)})")
        
        # Update doctor's availability and accepting status
        try:
            # CRITICAL: Ensure is_accepting_appointments is explicitly set as a Python boolean
            # Supabase might convert None to NULL, so we must explicitly pass False as False
            update_data = {
                "availability": availability,
            }
            
            # Explicitly set is_accepting_appointments - ensure it's a proper boolean
            # This prevents Supabase from treating it as NULL
            print(f"ğŸ” BEFORE UPDATE: is_accepting_appointments = {is_accepting_appointments} (type: {type(is_accepting_appointments)})")
            print(f"ğŸ” BEFORE UPDATE: is_accepting_appointments is False? {is_accepting_appointments is False}")
            print(f"ğŸ” BEFORE UPDATE: is_accepting_appointments == False? {is_accepting_appointments == False}")
            
            if is_accepting_appointments is False:
                update_data["is_accepting_appointments"] = False  # Explicit False
                print(f"âœ… Setting is_accepting_appointments to explicit False")
            elif is_accepting_appointments is True:
                update_data["is_accepting_appointments"] = True  # Explicit True
                print(f"âœ… Setting is_accepting_appointments to explicit True")
            else:
                # Fallback - shouldn't happen, but handle it
                update_data["is_accepting_appointments"] = bool(is_accepting_appointments)
                print(f"âš ï¸  Fallback: Setting is_accepting_appointments to bool({is_accepting_appointments}) = {bool(is_accepting_appointments)}")
            
            print(f"ğŸ” UPDATE DATA: {update_data}")
            print(f"ğŸ” UPDATE DATA is_accepting_appointments: {update_data['is_accepting_appointments']} (type: {type(update_data['is_accepting_appointments'])})")
            
            response = (
                supabase.service_client.table("doctor_profiles")
                .update(update_data)
                .eq("firebase_uid", uid)
                .execute()
            )

            if not response.data:
                print(f"ERROR: Supabase update returned no data for user {uid}")
                return jsonify({"success": False, "error": "Failed to update availability. Doctor profile may not exist."}), 400

            print(f"ğŸ” UPDATE RESPONSE: {response.data}")
            if response.data and len(response.data) > 0:
                response_value = response.data[0].get("is_accepting_appointments")
                print(f"ğŸ” UPDATE RESPONSE VALUE: {response_value} (type: {type(response_value)})")
                print(f"ğŸ” UPDATE RESPONSE VALUE is False? {response_value is False}")
                print(f"ğŸ” UPDATE RESPONSE VALUE == False? {response_value == False}")

            # Verify the update was successful by reading back the value
            verify_response = (
                supabase.service_client.table("doctor_profiles")
                .select("is_accepting_appointments")
                .eq("firebase_uid", uid)
                .execute()
            )
            
            # CRITICAL: Read back the actual saved value from database
            verified_value = is_accepting_appointments  # Fallback to what we tried to save
            if verify_response.data and len(verify_response.data) > 0:
                saved_raw = verify_response.data[0].get("is_accepting_appointments")
                # Check if column exists and value is not None
                if "is_accepting_appointments" in verify_response.data[0]:
                    print(f"ğŸ” VERIFY: Column exists in response")
                    print(f"ğŸ” VERIFY: saved_raw = {saved_raw} (type: {type(saved_raw)})")
                    print(f"ğŸ” VERIFY: saved_raw is None? {saved_raw is None}")
                    print(f"ğŸ” VERIFY: saved_raw == False? {saved_raw == False}")
                    print(f"ğŸ” VERIFY: saved_raw is False? {saved_raw is False}")
                    
                    if saved_raw is None:
                        # Value is NULL - this shouldn't happen if we saved False, but handle it
                        print(f"âš ï¸  WARNING: Saved value is NULL, using attempted value: {is_accepting_appointments}")
                        verified_value = is_accepting_appointments
                    else:
                        # Value exists - convert properly, preserving False
                        if isinstance(saved_raw, str):
                            verified_value = saved_raw.lower() in ('true', '1', 'yes', 'on')
                            print(f"ğŸ”„ VERIFY: Converted string '{saved_raw}' to boolean: {verified_value}")
                        else:
                            verified_value = bool(saved_raw)
                            print(f"âœ… VERIFY: Converted {saved_raw} (type: {type(saved_raw)}) to boolean: {verified_value}")
                        print(f"âœ… Verified saved value from DB: {verified_value} (raw: {saved_raw}, type: {type(saved_raw)})")
                else:
                    # Column doesn't exist
                    print(f"âš ï¸  Column doesn't exist in response, using attempted value: {is_accepting_appointments}")
                    verified_value = is_accepting_appointments
            else:
                print(f"âš ï¸  No data returned from verification query, using attempted value: {is_accepting_appointments}")
            
            print(f"ğŸ” FINAL VERIFIED VALUE: {verified_value} (type: {type(verified_value)})")
            print(f"DEBUG: Successfully updated availability for user {uid}")
            print(f"DEBUG: Verified is_accepting_appointments = {verified_value} (attempted: {is_accepting_appointments})")
            return jsonify({
                "success": True, 
                "availability": availability,
                "is_accepting_appointments": verified_value,  # Return verified value
                "message": "Availability updated successfully"
            }), 200
        
        except Exception as db_error:
            print(f"ERROR: Database update failed: {str(db_error)}")
            # Check if error is about missing column
            if "is_accepting_appointments" in str(db_error).lower() or "column" in str(db_error).lower():
                print(f"âš ï¸  Warning: is_accepting_appointments column may not exist. Updating availability only.")
                # Try updating without is_accepting_appointments
                try:
                    response = (
                        supabase.service_client.table("doctor_profiles")
                        .update({"availability": availability})
                        .eq("firebase_uid", uid)
                        .execute()
                    )
                    if response.data:
                        return jsonify({
                            "success": True, 
                            "availability": availability,
                            "message": "Availability updated successfully (Note: Please run database migration to enable toggle feature)"
                        }), 200
                except Exception as retry_error:
                    return jsonify({"success": False, "error": f"Database error: {str(retry_error)}"}), 500
            return jsonify({"success": False, "error": f"Database error: {str(db_error)}"}), 500

    except Exception as e:
        print(f"ERROR: Exception in update_doctor_availability: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500


@appointments_bp.route("/availability/<doctor_firebase_uid>", methods=["GET"])
@auth_required
def get_doctor_availability_by_uid(doctor_firebase_uid):
    """Get specific doctor's availability (for patients booking appointments)
    Returns availability in format that can be used to generate date-time slots"""
    try:
        print(f"ğŸ” Getting availability for doctor: {doctor_firebase_uid}")
        
        # Get doctor's availability and accepting status (handle gracefully if column doesn't exist)
        try:
            response = (
                supabase.client.table("doctor_profiles")
                .select("availability, is_accepting_appointments")
                .eq("firebase_uid", doctor_firebase_uid)
                .execute()
            )
        except Exception as select_error:
            # If column doesn't exist, try without it
            print(f"âš ï¸  Warning: Error selecting is_accepting_appointments: {select_error}")
            print(f"âš ï¸  Falling back to availability only (assuming is_accepting_appointments = True)")
            response = (
                supabase.client.table("doctor_profiles")
                .select("availability")
                .eq("firebase_uid", doctor_firebase_uid)
                .execute()
            )

        if not response.data:
            print(f"âŒ Doctor not found: {doctor_firebase_uid}")
            return jsonify({"success": False, "error": "Doctor not found"}), 404

        availability = response.data[0].get("availability", {})
        is_accepting_appointments = response.data[0].get("is_accepting_appointments", True)
        
        print(f"ğŸ” Doctor availability data: {availability}")
        print(f"ğŸ” Is accepting appointments: {is_accepting_appointments}")
        
        # If doctor is not accepting appointments, return empty availability
        if not is_accepting_appointments:
            print(f"âš ï¸  Doctor {doctor_firebase_uid} is not accepting appointments")
            return jsonify({
                "success": True,
                "availability": {},
                "schedule": availability,
                "message": "Doctor is currently not accepting appointments"
            }), 200
        
        # New format with multiple ranges: { time_ranges: [{ start_time, end_time, interval }, ...] }
        # or legacy single range: { start_time, end_time, interval }
        if isinstance(availability, dict):
            time_ranges = []
            
            # Check for new format with time_ranges array
            if "time_ranges" in availability and isinstance(availability["time_ranges"], list):
                time_ranges = availability["time_ranges"]
            # Legacy single range format
            elif "start_time" in availability:
                time_ranges = [{
                    "start_time": availability.get("start_time", "07:00"),
                    "end_time": availability.get("end_time", "17:00"),
                    "interval": availability.get("interval", 30)
                }]
            
            if time_ranges:
                # Generate time slots for next 30 days based on Asia/Manila timezone
                time_slots_per_date = {}
                now_manila = get_manila_now()
                today_manila = now_manila.date()
                
                for day_offset in range(30):
                    date = today_manila + timedelta(days=day_offset)
                    date_str = date.isoformat()
                    
                    # Generate time slots for this date from all ranges
                    all_slots = []
                    
                    for time_range in time_ranges:
                        start_time = time_range.get("start_time", "07:00")
                        end_time = time_range.get("end_time", "17:00")
                        interval = time_range.get("interval", 30)
                        
                        # Parse times
                        start_hour, start_min = map(int, start_time.split(":"))
                        end_hour, end_min = map(int, end_time.split(":"))
                        start_minutes = start_hour * 60 + start_min
                        end_minutes = end_hour * 60 + end_min
                        
                        # Generate time slots for this range
                        current_minutes = start_minutes
                        
                        while current_minutes < end_minutes:
                            hour = current_minutes // 60
                            minute = current_minutes % 60
                            time_str = f"{hour:02d}:{minute:02d}"
                            
                            # Check if this time slot is in the future (for today only)
                            if day_offset == 0:
                                # Create datetime in Manila timezone for this slot
                                slot_time = datetime.strptime(time_str, "%H:%M").time()
                                slot_datetime_naive = datetime.combine(date, slot_time)
                                
                                # Localize to Manila timezone
                                if hasattr(MANILA_TZ, 'localize'):
                                    # pytz timezone
                                    slot_datetime_manila = MANILA_TZ.localize(slot_datetime_naive)
                                else:
                                    # zoneinfo or timezone offset
                                    slot_datetime_manila = slot_datetime_naive.replace(tzinfo=MANILA_TZ)
                                
                                # Only include if slot is in the future
                                if slot_datetime_manila > now_manila:
                                    if time_str not in all_slots:
                                        all_slots.append(time_str)
                            else:
                                # For future dates, include all slots
                                if time_str not in all_slots:
                                    all_slots.append(time_str)
                            
                            current_minutes += interval
                    
                    if all_slots:
                        time_slots_per_date[date_str] = sorted(all_slots)
                
                return jsonify({
                    "success": True, 
                    "availability": time_slots_per_date,
                    "schedule": availability  # Include original schedule for reference
                }), 200
        
        # Old format: array of date slots (backward compatibility)
        elif isinstance(availability, list):
            return jsonify({"success": True, "availability": availability}), 200
        
        # Empty or invalid format
        else:
            return jsonify({"success": True, "availability": {}}), 200

    except Exception as e:
        print(f"Error fetching doctor availability: {str(e)}")
        return jsonify({"success": False, "error": str(e)}), 500
